{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worksheet Lab</title>


    <!-- jQuery and jQuery UI (for draggable and resizable features) -->
   <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>



    <style>
        :root {
            --primary: #1A73E8;
            --accent: #F2A03D;
            --secondary-accent: #34A853;
            --background: #F2EFE9;
            --dark: #0D0D0D;
            --highlight: #A6173D;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background);
            color: var(--dark);
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            background-color: var(--primary);
            color: #fff;
            width: 250px;
            padding: 20px;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            overflow-y: auto;
        }

.sidebar input[type="text"],
.sidebar input[type="number"],
.sidebar select {
    width: 100%;
    max-width: 210px; /* prevent from touching edge */
    margin-bottom: 12px;
}

        .main-content {
            margin-left: 250px;
            padding: 40px;
            flex: 1;
        }

        .toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 20px;
        }

#worksheet-title {
  text-align: center;
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 15px;
}

        .pane {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 1200px;
            margin: auto;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 8px;
            margin: 8px 0 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        button {
            background-color: var(--accent);
            color: #fff;
            border: none;
            padding: 10px 16px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: var(--highlight);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .worksheet-page {
            background: #fff;
            width: 21cm;
            height: 29.7cm;
            padding: 20px;
            border-radius: 5px;
  box-shadow: 0 12px 20px rgba(0, 0, 0, 0.25);
            margin-top: 30px;
            position: relative;
  background-image: linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
  background-size: 20px 20px;
        }

        .worksheet-page img.worksheet-logo {
            width: 120px;
            margin-bottom: 10px;
    	display: block;
  	  margin: 0 auto 10px;
        }

        .worksheet-content {
            width: 100%;
        }

        .worksheet-box {
            position: absolute;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
            white-space: normal;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .modal-content .close {
            float: right;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .feature-table {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
        }

        .feature-table th,
        .feature-table td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }

        .feature-table th {
            background-color: #eee;
        }

        .premium-restriction {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-right: 20px;
        }

        .upgrade-message {
            color: var(--dark);
        }

.upgrade-btn {
    background-color: var(--accent);
    color: #fff;
    padding: 8px 14px;
    border-radius: 5px;
    font-weight: bold;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    width: fit-content;
  transition: all 0.3s ease;
  transform: translateY(0);
}

.upgrade-btn:hover {
    background-color: var(--highlight);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

    </style>
</head>
<body>

    <!-- Main Content -->
    <div class="main-content">
        <div class="toolbar">
<!-- Print Button (Disabled for Basic Users) -->
{% if request.user.is_premium %}
    <button id="printBtn" onclick="printWorksheet()">Print Worksheet üñ®Ô∏è</button>
    <button id="downloadBtn" onclick="downloadWorksheetPDF()">Download as PDF üìÑ</button>
{% else %}
<div class="premium-restriction">
    <p class="upgrade-message">
        <span class="lock-icon">üîí</span> Printing and exporting are Premium features.
    </p>
<a href="#" class="upgrade-btn" onclick="openUpgradeModal()">Upgrade to Premium</a>

</div>
{% endif %}
            <button onclick="goBack()">Back to Dashboard</button>
        </div>

        <!-- Worksheet Lab Pane -->
        <div class="pane" id="worksheet-lab">
            <div class="container">
                <div class="sidebar">
                    <!-- Worksheet Title Input -->
                    <h3>Set Worksheet Title:</h3>
                    <input type="text" id="worksheet-title-input" placeholder="Enter worksheet title">
                    <button onclick="updateWorksheetTitle()">Update Title</button>

                    <h2>Add a Box</h2>
                    <label for="task-type">Select Task Type:</label>
                    <select id="task-type">
                        <option value="translate_source_to_target">Translate from Source to Target</option>
                        <option value="translate_target_to_source">Translate from Target to Source</option>
                        <option value="match_up">Match Up</option>
                        <option value="complete_missing_letters">Complete the Missing Letters</option>
                        <option value="complete_missing_vowels">Complete the Missing Vowels</option>
                        <option value="multiple_choice">Multiple Choice Translation</option>
                        <option value="faulty_translation">Faulty Translation</option>
                        <option value="unscramble">Unscramble the Letters</option>
   			<option value="wordsearch">Wordsearch Puzzle</option>
			<option value="crossword">Crossword Puzzle</option>
			<option value="cryptogram">Cryptogram Puzzle</option>
                    </select>

                    <label for="question-count">Number of Questions:</label>
                    <input type="number" id="question-count" min="1" max="10" value="1">

                    <!-- Compact Button Row Above Preview Box -->
                    <div class="button-row">
                        <button onclick="generateBox()" title="Generate Preview">ü™Ñ</button>
                        <button onclick="addToWorksheet()" title="Add to Worksheet">‚ûï</button>
                        <button onclick="refreshWords()" title="Refresh Words">üîÑ</button>
                    </div>

                    <h3>Preview:</h3>
                    <div id="box-preview" class="box"></div>
                </div>

                <!-- Worksheet Print Preview (More like a real page) -->
                <div class="worksheet-page">
                    <img src="{% static 'pavonify_bird.png' %}" alt="Pavonify Logo" class="worksheet-logo">
                    <h1 id="worksheet-title">{{ vocab_list.name }} Worksheet</h1>
                    <hr>
                    <div id="worksheet-preview" class="worksheet-content">
                        <!-- Tasks will be added here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

<!-- Upgrade Modal -->
<div id="upgrade-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <!-- Close button -->
    <span onclick="closeUpgradeModal()" style="float:right; cursor:pointer; font-size: 20px;">&times;</span>

    <!-- Paste teacher-upgrade pane content here -->
    <h2>Upgrade to Premium</h2>
    <p>Get full access to all features for just <strong>¬£2.99 per month</strong>.</p>
    <table class="feature-table">
      <tr><th>Feature</th><th>Basic</th><th>Premium</th></tr>
      <tr><td>Create Vocabulary Lists</td><td>5</td><td>‚úî</td></tr>
      <tr><td>Create Classes</td><td>2</td><td>‚úî</td></tr>
      <tr><td>Create Assignments</td><td>1</td><td>‚úî</td></tr>
      <tr><td>Assignment Analytics</td><td>‚ùå</td><td>‚úî</td></tr>
      <tr><td>Unlimited Students</td><td>‚ùå</td><td>‚úî</td></tr>
      <tr><td>Worksheet Lab</td><td>‚ùå</td><td>‚úî</td></tr>
    </table>
    <button id="upgrade-btn" class="btn btn-upgrade">Upgrade to Premium</button>
  </div>
</div>

<script>
  function openUpgradeModal() {
    document.getElementById("upgrade-modal").style.display = "block";
  }

  function closeUpgradeModal() {
    document.getElementById("upgrade-modal").style.display = "none";
  }

  // Stripe upgrade click handler
  document.addEventListener("DOMContentLoaded", () => {
    const upgradeBtn = document.getElementById("upgrade-btn");
    if (upgradeBtn) {
      upgradeBtn.addEventListener("click", async function (event) {
        event.preventDefault();
        const csrftoken = document.querySelector("[name=csrfmiddlewaretoken]").value;

        const response = await fetch("{% url 'create_checkout_session' %}", {
          method: "POST",
          headers: {
            "X-CSRFToken": csrftoken,
            "Content-Type": "application/json"
          },
        });

        const data = await response.json();
        if (data.checkout_url) {
          window.location.href = data.checkout_url;
        } else {
          alert("Error: " + data.error);
        }
      });
    }
  });

  // Close modal when clicking outside
  window.onclick = function(event) {
    const modal = document.getElementById("upgrade-modal");
    if (event.target === modal) {
      closeUpgradeModal();
    }
  }
</script>


    <!-- JSON Data for Words -->
    <script>


        function adjustSidebarHeight() {
            const sidebar = document.querySelector('.sidebar');
            const contentHeight = sidebar.scrollHeight;

            // Ensure sidebar expands when new content is added
            sidebar.style.height = contentHeight + "px";
        }

        function updateWorksheetTitle() {
            const titleInput = document.getElementById('worksheet-title-input');
            const worksheetTitle = document.getElementById('worksheet-title');

            if (titleInput.value.trim() !== "") {
                worksheetTitle.textContent = titleInput.value;
            } else {
                alert("Please enter a valid title.");
            }
        }

        // Set default title when the page loads
        window.onload = function () {
            const titleInput = document.getElementById('worksheet-title-input');
            const defaultTitle = "{{ vocab_list.name }} Worksheet";
            titleInput.value = defaultTitle;
        };

        const words = JSON.parse('{{ words_json|escapejs }}');

// Global variables for Wordsearch
var currentTaskType = "";
var wordsearchSelectedWords = [];

function printWorksheet() {
    const worksheet = document.querySelector('.worksheet-page');
    const originalContents = document.body.innerHTML;

    // Replace page content with only the worksheet
    document.body.innerHTML = worksheet.outerHTML;

    // Trigger print
    window.print();

    // Restore the original page after printing
    document.body.innerHTML = originalContents;

    // Reattach event listeners (if needed)
    attachDragAndResize();
}



        function goBack() {
            window.history.back();
        }

function generateBox() {
    const taskType = document.getElementById('task-type').value;
    currentTaskType = taskType; // Save the current task type globally.
    const questionCount = parseInt(document.getElementById('question-count').value, 10);
    const previewDiv = document.getElementById('box-preview');

    if (words.length < questionCount) {
        alert('Not enough words in the vocabulary list!');
        return;
    }

    // Shuffle words and select required amount
    const shuffledWords = [...words].sort(() => 0.5 - Math.random()).slice(0, questionCount);
    let content = '<strong>';

    switch (taskType) {
        case 'translate_source_to_target':
            content += 'Translate these words:</strong><br>';
            shuffledWords.forEach((word, index) => {
                content += `${index + 1}. ${word.word} ‚ûù _______<br>`;
            });
            break;

        case 'translate_target_to_source':
            content += 'Translate these words into your native language:</strong><br>';
            shuffledWords.forEach((word, index) => {
                content += `${index + 1}. ${word.translation} ‚ûù _______<br>`;
            });
            break;

        case 'match_up':
            content += 'Match the words with their meanings:</strong><br>';
            let answers = shuffledWords.map(w => w.translation).sort(() => Math.random() - 0.5);
            shuffledWords.forEach((word, index) => {
                content += `${index + 1}. ${word.word} _______ ${String.fromCharCode(97 + index)}) ${answers[index]}<br>`;
            });
            break;

        case 'complete_missing_letters':
            content += 'Fill in the missing letters:</strong><br>';
            shuffledWords.forEach((word, index) => {
                let missingLetters = word.translation.replace(/[bcdfghjklmnpqrstvwxyz]/gi, '_'); // Remove consonants
                content += `${index + 1}. ${missingLetters} (${word.word})<br>`; // Add source word in brackets
            });
            break;

        case 'complete_missing_vowels':
            content += 'Fill in the missing vowels:</strong><br>';
            shuffledWords.forEach((word, index) => {
                let missingVowels = word.translation.replace(/[aeiou]/gi, '_'); // Remove vowels
                content += `${index + 1}. ${missingVowels} (${word.word})<br>`; // Add source word in brackets
            });
            break;

        case 'multiple_choice':
            content += 'Select the correct translation:</strong><br>';
            shuffledWords.forEach((word, index) => {
                let incorrectChoices = [...words]
                    .filter(w => w.translation !== word.translation)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 2);
                
                let choices = [word.translation, ...incorrectChoices.map(w => w.translation)]
                    .sort(() => Math.random() - 0.5);
                
                content += `${index + 1}. ${word.word}: (${choices.join(', ')})<br>`;
            });
            break;

        case 'faulty_translation':
            content += 'Tick ‚úî if correct, ‚úñ if incorrect:</strong><br>';
            shuffledWords.forEach((word, index) => {
                let correct = Math.random() < 0.5; // 50% chance of being correct
                let displayedTranslation = correct ? word.translation : words[Math.floor(Math.random() * words.length)].translation;
                
                content += `${index + 1}. ${word.word} ‚ûù ${displayedTranslation}  (‚úî/‚úñ)<br>`;
            });
            break;

        case 'unscramble':
            content += 'Unscramble the words:</strong><br>';
            shuffledWords.forEach((word, index) => {
                let scrambled = word.translation.split('').sort(() => 0.5 - Math.random()).join('');
                content += `${index + 1}. ${scrambled} ‚ûù _______ (${word.word})<br>`; // Add source word in brackets
            });
            break;
        case 'wordsearch':
            // For wordsearch, save the selected words and show a preview list.
            wordsearchSelectedWords = shuffledWords;
            content += 'Wordsearch Preview</strong><br>';
            content += 'The following words will be hidden in the puzzle:<br><ul>';
            shuffledWords.forEach((word) => {
                content += `<li>${word.translation.toUpperCase()}</li>`;
            });
            content += '</ul>';
            break;
	case 'crossword':
            // For crossword, use the target language as the answer and source as clue.
            puzzleSelectedWords = shuffledWords; // Save globally.
            content += 'Crossword Preview</strong><br>';
            content += 'The following target language words will be hidden in the puzzle:<br><ul>';
            shuffledWords.forEach((word) => {
                content += `<li>${word.translation.toUpperCase()}</li>`;
            });
            content += '</ul>';
            break;
	case 'cryptogram':
   	 // Save the selected words in a global variable (we reuse puzzleSelectedWords).
    		puzzleSelectedWords = shuffledWords;
    content += 'Cryptogram Preview</strong><br>';
    content += 'The following target language words will be encoded in the puzzle:<br><ul>';
    shuffledWords.forEach((word) => {
        content += `<li>${word.translation.toUpperCase()}</li>`;
    });
    content += '</ul>';
    break;
    }

    previewDiv.innerHTML = content;

    // Adjust preview box height dynamically
    previewDiv.style.height = "auto";
    previewDiv.style.overflowY = "auto";
    previewDiv.style.display = "block";
    previewDiv.style.maxHeight = "300px";

    // Allow sidebar to expand if needed
    document.querySelector(".sidebar").style.maxHeight = "none";
}

function generateWordsearchPuzzle(selectedWords) {
    // Create lists of target words (uppercase) and clues.
    var wordList = selectedWords.map(function(w) { return w.translation.toUpperCase(); });
    var clueList = selectedWords.map(function(w) { return w.word; });

    // Determine grid size: at least 15, or large enough for the longest word.
    var maxWordLength = Math.max.apply(null, wordList.map(function(w) { return w.length; }));
    var gridSize = Math.max(15, maxWordLength + 2);

    // Create an empty grid (2D array).
    var grid = [];
    for (var r = 0; r < gridSize; r++) {
        grid[r] = [];
        for (var c = 0; c < gridSize; c++) {
            grid[r][c] = "";
        }
    }

    // Define the eight possible directions.
    var directions = [
        {dx: 0, dy: 1},    // down
        {dx: 1, dy: 0},    // right
        {dx: 0, dy: -1},   // up
        {dx: -1, dy: 0},   // left
        {dx: 1, dy: 1},    // diagonal down-right
        {dx: -1, dy: -1},  // diagonal up-left
        {dx: -1, dy: 1},   // diagonal down-left
        {dx: 1, dy: -1}    // diagonal up-right
    ];

    // Helper function: check if a word fits starting at (x, y) in direction (dx, dy).
    function canPlaceWord(word, x, y, dx, dy) {
        for (var i = 0; i < word.length; i++) {
            var newX = x + dx * i;
            var newY = y + dy * i;
            if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize)
                return false;
            if (grid[newY][newX] !== "" && grid[newY][newX] !== word[i])
                return false;
        }
        return true;
    }

    // Helper function: place a word in the grid.
    function placeWord(word) {
        var placed = false;
        var attempts = 0;
        while (!placed && attempts < 100) {
            attempts++;
            var dir = directions[Math.floor(Math.random() * directions.length)];
            var startX = Math.floor(Math.random() * gridSize);
            var startY = Math.floor(Math.random() * gridSize);
            if (canPlaceWord(word, startX, startY, dir.dx, dir.dy)) {
                for (var i = 0; i < word.length; i++) {
                    grid[startY + dir.dy * i][startX + dir.dx * i] = word[i];
                }
                placed = true;
            }
        }
        if (!placed) {
            console.log("Could not place word: " + word);
        }
    }

    // Place each word.
    wordList.forEach(function(word) {
        placeWord(word);
    });

    // Fill in any empty cells with random letters.
    for (var r = 0; r < gridSize; r++) {
        for (var c = 0; c < gridSize; c++) {
            if (grid[r][c] === "") {
                grid[r][c] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
            }
        }
    }

    // Build the HTML table for the grid.
    var gridHtml = "<table style='border-collapse: collapse;'>";
    for (var r = 0; r < gridSize; r++) {
        gridHtml += "<tr>";
        for (var c = 0; c < gridSize; c++) {
            gridHtml += `<td style="border: 1px solid #000; width: 20px; height: 20px; text-align: center; font-family: monospace; padding: 2px;">${grid[r][c]}</td>`;
        }
        gridHtml += "</tr>";
    }
    gridHtml += "</table>";

    // Build the clues list (using the translations).
    var cluesHtml = "<ul style='list-style: none; padding: 0;'>";
    clueList.forEach(function(clue, index) {
        cluesHtml += `<li>${index + 1}. ${clue}</li>`;
    });
    cluesHtml += "</ul>";

    // Combine the grid and clues into final content.
    var content = "<strong>Wordsearch Puzzle</strong><br><br>";
    content += "Find the hidden words in the grid below. Use the clues (translations) to help you.<br><br>";
    content += gridHtml;
    content += "<br>Clues:<br>" + cluesHtml;
    return content;
}

function generateCrosswordPuzzle(selectedWords) {
    // We'll use a fixed grid size.
    const gridSize = 15;
    // Create a grid (2D array) of nulls.
    let grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
    // This array will hold details of each successfully placed word.
    let placedWords = [];

    // --- Place the first word in the center (horizontally) ---
    let first = selectedWords[0];
    let answer = first.translation.toUpperCase(); // Target language answer.
    let clueText = first.word; // Source language clue.
    let startRow = Math.floor(gridSize / 2);
    let startCol = Math.floor((gridSize - answer.length) / 2);
    for (let i = 0; i < answer.length; i++) {
        grid[startRow][startCol + i] = answer[i];
    }
    placedWords.push({ answer, clue: clueText, row: startRow, col: startCol, direction: "across" });

    // --- Try to place the remaining words by intersecting with placed words ---
    for (let idx = 1; idx < selectedWords.length; idx++) {
        let current = selectedWords[idx];
        answer = current.translation.toUpperCase();
        clueText = current.word;
        let placed = false;
        
        // Attempt to intersect with any already placed word.
        for (let pword of placedWords) {
            for (let i = 0; i < pword.answer.length; i++) {
                let letter = pword.answer[i];
                for (let j = 0; j < answer.length; j++) {
                    if (answer[j] === letter) {
                        // If pword is placed horizontally, try placing current vertically.
                        if (pword.direction === "across") {
                            let intersectRow = pword.row;
                            let intersectCol = pword.col + i;
                            let candidateRow = intersectRow - j;
                            let candidateCol = intersectCol;
                            if (candidateRow >= 0 && candidateRow + answer.length <= gridSize) {
                                let conflict = false;
                                for (let k = 0; k < answer.length; k++) {
                                    let r = candidateRow + k;
                                    let c = candidateCol;
                                    if (grid[r][c] !== null && grid[r][c] !== answer[k]) {
                                        conflict = true;
                                        break;
                                    }
                                }
                                if (!conflict) {
                                    for (let k = 0; k < answer.length; k++) {
                                        grid[candidateRow + k][candidateCol] = answer[k];
                                    }
                                    placedWords.push({ answer, clue: clueText, row: candidateRow, col: candidateCol, direction: "down" });
                                    placed = true;
                                    break;
                                }
                            }
                        }
                        // If pword is vertical, try placing current horizontally.
                        else if (pword.direction === "down") {
                            let intersectRow = pword.row + i;
                            let intersectCol = pword.col;
                            let candidateRow = intersectRow;
                            let candidateCol = intersectCol - j;
                            if (candidateCol >= 0 && candidateCol + answer.length <= gridSize) {
                                let conflict = false;
                                for (let k = 0; k < answer.length; k++) {
                                    let r = candidateRow;
                                    let c = candidateCol + k;
                                    if (grid[r][c] !== null && grid[r][c] !== answer[k]) {
                                        conflict = true;
                                        break;
                                    }
                                }
                                if (!conflict) {
                                    for (let k = 0; k < answer.length; k++) {
                                        grid[candidateRow][candidateCol + k] = answer[k];
                                    }
                                    placedWords.push({ answer, clue: clueText, row: candidateRow, col: candidateCol, direction: "across" });
                                    placed = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (placed) break;
            }
            if (placed) break;
        }
        // If no intersection was found, attempt to place it randomly horizontally.
        if (!placed) {
            let tries = 0;
            while (!placed && tries < 100) {
                tries++;
                let candidateRow = Math.floor(Math.random() * gridSize);
                let candidateCol = Math.floor(Math.random() * (gridSize - answer.length + 1));
                let conflict = false;
                for (let k = 0; k < answer.length; k++) {
                    if (grid[candidateRow][candidateCol + k] !== null && grid[candidateRow][candidateCol + k] !== answer[k]) {
                        conflict = true;
                        break;
                    }
                }
                if (!conflict) {
                    for (let k = 0; k < answer.length; k++) {
                        grid[candidateRow][candidateCol + k] = answer[k];
                    }
                    placedWords.push({ answer, clue: clueText, row: candidateRow, col: candidateCol, direction: "across" });
                    placed = true;
                }
            }
        }
    }

// --- Revised Clue Numbering (treating "" as blank) ---
let numbers = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
let clueNumber = 1;
for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
        // Only consider cells that contain a letter (non-blank)
        if (grid[r][c] !== "") {
            // A cell gets a new number if either:
            // - It is at the left edge OR the cell immediately to its left is blank ("")
            // OR
            // - It is at the top edge OR the cell immediately above is blank ("")
            if ((c === 0 || grid[r][c - 1] === "") || (r === 0 || grid[r - 1][c] === "")) {
                numbers[r][c] = clueNumber;
                clueNumber++;
            }
        }
    }
}

// Now assign these numbers to the placed words.
placedWords.forEach(function(pword) {
    pword.number = numbers[pword.row][pword.col];
});


    placedWords.forEach(function(pword) {
        pword.number = numbers[pword.row][pword.col];
    });

    // Separate clues by direction and sort by clue number.
    let acrossClues = placedWords.filter(w => w.direction === "across").sort((a, b) => a.number - b.number);
    let downClues = placedWords.filter(w => w.direction === "down").sort((a, b) => a.number - b.number);

    // --- Build the HTML for the grid ---
    let gridHtml = "<table style='border-collapse: collapse;'>";
    for (let r = 0; r < gridSize; r++) {
        gridHtml += "<tr>";
        for (let c = 0; c < gridSize; c++) {
            if (grid[r][c] !== null) {
                let num = numbers[r][c];
                gridHtml += `<td style="border: 1px solid #000; width: 25px; height: 25px; position: relative;">`;
                if (num > 0) {
                    gridHtml += `<div style="position: absolute; top: 0; left: 0; font-size: 8px;">${num}</div>`;
                }
                // Leave the cell blank so the solver can fill it in.
                gridHtml += `</td>`;
            } else {
                gridHtml += `<td style="border: 1px solid #000; width: 25px; height: 25px; background-color: #000;"></td>`;
            }
        }
        gridHtml += "</tr>";
    }
    gridHtml += "</table>";

    // --- Build the clues HTML ---
    let cluesHtml = "<div style='display: flex; justify-content: space-around;'><div><strong>Across</strong><br><ul style='list-style: none; padding: 0;'>";
    acrossClues.forEach(function(clue) {
        cluesHtml += `<li>${clue.number}. ${clue.clue}</li>`;
    });
    cluesHtml += "</ul></div>";
    cluesHtml += "<div><strong>Down</strong><br><ul style='list-style: none; padding: 0;'>";
    downClues.forEach(function(clue) {
        cluesHtml += `<li>${clue.number}. ${clue.clue}</li>`;
    });
    cluesHtml += "</ul></div></div>";

    let content = "<strong>Crossword Puzzle</strong><br><br>";
    content += gridHtml;
    content += "<br>Clues:<br>" + cluesHtml;
    return content;
}

function generateCryptogramPuzzle(selectedWords) {
    // Create a random substitution cipher for A-Z.
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const shuffled = alphabet.slice().sort(() => Math.random() - 0.5);
    let cipher = {};
    for (let i = 0; i < alphabet.length; i++) {
        cipher[alphabet[i]] = shuffled[i];
    }

    // For each selected word, encode the target word using the cipher.
    let encodedItems = selectedWords.map(function(wordObj) {
        let answer = wordObj.translation.toUpperCase();
        let encoded = "";
        for (let char of answer) {
            if (/[A-Z]/.test(char)) {
                encoded += cipher[char];
            } else {
                encoded += char;
            }
        }
        return { encoded: encoded, clue: wordObj.word };
    });

    // Build HTML for the cryptogram puzzle.
    let content = "<strong>Cryptogram Puzzle</strong><br><br>";
    content += "Decode the following encoded words. Use the source language clues to help you.<br><br>";
    content += "<ul style='list-style: none; padding: 0;'>";
    encodedItems.forEach(function(item, index) {
        content += `<li><strong>${index+1}.</strong> ${item.encoded} (Clue: ${item.clue})</li>`;
    });
    content += "</ul>";

    // Build the substitution key grid.
    // First row: Letters A-Z
    let alphaGrid = "<br><br><strong>Substitution Key:</strong><br>";
    alphaGrid += "<table style='border-collapse: collapse; margin-top: 10px;'>";
    alphaGrid += "<tr>";
    for (let i = 65; i <= 90; i++) {
         let letter = String.fromCharCode(i);
         alphaGrid += `<td style="border: 1px solid #000; width: 25px; height: 25px; text-align: center;">${letter}</td>`;
    }
    alphaGrid += "</tr>";
    // Second row: Empty cells for student entries.
    alphaGrid += "<tr>";
    for (let i = 65; i <= 90; i++) {
         alphaGrid += `<td style="border: 1px solid #000; width: 25px; height: 25px; text-align: center;">&nbsp;</td>`;
    }
    alphaGrid += "</tr>";
    alphaGrid += "</table>";

    // Append the substitution key grid to the puzzle content.
    content += alphaGrid;

    return content;
}



function addToWorksheet() {
    const previewDiv = document.getElementById('box-preview');
    const worksheetDiv = document.getElementById('worksheet-preview');
    const worksheetPage = document.querySelector('.worksheet-page'); // Ensure box stays inside this
    let boxContent = "";


    const taskTypeValue = document.getElementById('task-type').value;
    if (taskTypeValue === 'wordsearch') {
        boxContent = generateWordsearchPuzzle(wordsearchSelectedWords);
    } else if (taskTypeValue === 'crossword') {
        boxContent = generateCrosswordPuzzle(puzzleSelectedWords);
    } else if (taskTypeValue === 'cryptogram') {
        boxContent = generateCryptogramPuzzle(puzzleSelectedWords);
    } else {
        boxContent = previewDiv.innerHTML;
    }

    if (boxContent.trim()) {
        const box = document.createElement('div');
        box.className = 'worksheet-box';
        box.innerHTML = boxContent;

        // Auto-adjust width and height based on content
        box.style.width = 'auto';
        box.style.height = 'auto';

        // Top-right control div for drag and remove icons
        const controlDiv = document.createElement('div');
        controlDiv.className = 'box-controls';

        // Drag Handle
        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '‚†ø'; // Unicode for drag icon

        // Remove Button (X)
        const removeButton = document.createElement('span');
        removeButton.textContent = '‚úñ';
        removeButton.className = 'remove-box';
        removeButton.onclick = function () {
            box.remove();
        };

        // Append icons to control div
        controlDiv.appendChild(dragHandle);
        controlDiv.appendChild(removeButton);
        box.appendChild(controlDiv);

        // Create a separate resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        box.appendChild(resizeHandle);

        // **Find next available position within the worksheet page**
        let newX = 20; // Start position (left padding)
        let newY = 220; // Start position (below the logo/title area)
        const gridSize = 20; // Snap to grid

        // Get all existing boxes within the page
        const allBoxes = document.querySelectorAll('.worksheet-page .worksheet-box');
        if (allBoxes.length > 0) {
            let lastBox = allBoxes[allBoxes.length - 1]; // Get the last added box
            let lastRect = lastBox.getBoundingClientRect();
            let pageRect = worksheetPage.getBoundingClientRect();

            // Calculate potential next position (horizontally first)
            newX = lastRect.right - pageRect.left + gridSize; // Move right
            newY = lastRect.top - pageRect.top; // Keep same row

            // If the new position goes beyond the page width, move to the next row
            if (newX + 200 > pageRect.width) { // Assuming 200px min box width
                newX = 20; // Reset to left
                newY += lastRect.height + gridSize; // Move to next row
            }

            // **Ensure it doesn't go into the protected title area**
            if (newY < 160) {
                newY = 160; // Force position below title/logo area
            }

            // Prevent boxes from going outside the worksheet page
            if (newY + 100 > pageRect.height) { // Assuming 100px min box height
                alert("No more space on the worksheet!");
                return;
            }
        }

        // Apply position with snapping
        box.style.left = `${Math.round(newX / gridSize) * gridSize}px`;
        box.style.top = `${Math.round(newY / gridSize) * gridSize}px`;

        worksheetDiv.appendChild(box);

        // Make the box draggable ONLY from the drag handle
        $(box).draggable({
            grid: [20, 20], // Snap to grid
            containment: ".worksheet-page", // Ensure it stays inside the worksheet
            handle: ".drag-handle", // Dragging is only allowed on the drag icon
            cancel: ".resize-handle" // Prevent dragging while resizing
        });

        // Make the box resizable (ONLY on the resize handle)
        $(box).resizable({
            handles: { "se": ".resize-handle" }, // Only bottom-right corner resizable
            minWidth: 150,
            maxWidth: worksheetPage.clientWidth - 40, // Prevent overflowing width
            minHeight: 50,
            maxHeight: worksheetPage.clientHeight - 40, // Prevent overflowing height
            grid: [20, 20], // Snap resizing to the same grid as dragging
            start: function () {
                $(this).draggable("disable"); // Disable dragging while resizing
            },
            stop: function () {
                $(this).draggable("enable"); // Re-enable dragging after resizing
            }
        });

        previewDiv.innerHTML = ''; // Clear preview
    } else {
        alert('Please generate a task first!');
    }
}




function refreshWords() {
    generateBox(); // Simply regenerate the box with new words
}


function downloadWorksheetPDF() {
    const worksheet = document.querySelector('.worksheet-page');

    if (!worksheet) {
        alert("Worksheet not found!");
        return;
    }

    // Get the vocab list name
    let vocabListName = document.getElementById('worksheet-title').innerText.trim();
    if (!vocabListName) vocabListName = "Worksheet"; // Fallback name

    // Generate timestamp
    const now = new Date();
    const timestamp = now.toISOString().slice(0, 19).replace(/[-T:]/g, ""); // Format: YYYYMMDD_HHMMSS

    // Construct the filename
    const filename = `${vocabListName}_Worksheet_${timestamp}.pdf`;

    // Clone the worksheet to avoid modifying the original
    const clonedWorksheet = worksheet.cloneNode(true);
    const tempContainer = document.createElement('div');
    tempContainer.appendChild(clonedWorksheet);

    // Remove UI controls (drag, resize, delete)
    tempContainer.querySelectorAll('.remove-box, .drag-handle, .resize-handle').forEach(el => el.remove());

    // Get all original worksheet boxes and their positions
    const originalBoxes = worksheet.querySelectorAll('.worksheet-box');
    const clonedBoxes = tempContainer.querySelectorAll('.worksheet-box');

    originalBoxes.forEach((box, index) => {
        const rect = box.getBoundingClientRect();
        const pageRect = worksheet.getBoundingClientRect();
        
        // Apply exact position from original worksheet
        clonedBoxes[index].style.position = 'absolute';
        clonedBoxes[index].style.left = `${rect.left - pageRect.left}px`;
        clonedBoxes[index].style.top = `${rect.top - pageRect.top}px`;
        clonedBoxes[index].style.width = `${rect.width}px`;
        clonedBoxes[index].style.height = `${rect.height}px`;
        clonedBoxes[index].style.border = '1px solid black';
        clonedBoxes[index].style.padding = '10px';
        clonedBoxes[index].style.boxShadow = 'none';
    });

    // Ensure worksheet is centered and formatted properly
    clonedWorksheet.style.backgroundImage = 'none';
    clonedWorksheet.style.position = 'relative';
    clonedWorksheet.style.margin = '0 auto';
    clonedWorksheet.style.padding = '20px';
    clonedWorksheet.style.width = '21cm';
    clonedWorksheet.style.height = '29.7cm';
    clonedWorksheet.style.overflow = 'hidden';

    // Adjust worksheet title
    const worksheetTitle = tempContainer.querySelector('#worksheet-title');
    if (worksheetTitle) {
        worksheetTitle.style.textAlign = 'center';
        worksheetTitle.style.fontSize = '20px';
        worksheetTitle.style.fontWeight = 'bold';
        worksheetTitle.style.marginBottom = '15px';
    }

    // Adjust logo size and placement
    const worksheetLogo = tempContainer.querySelector('.worksheet-logo');
    if (worksheetLogo) {
        worksheetLogo.style.display = 'block';
        worksheetLogo.style.margin = '0 auto 10px';
        worksheetLogo.style.maxWidth = '150px';
    }

    // Convert to PDF while keeping exact positions
    html2pdf().set({
        margin: [0, 0, 0, 0], // Remove margins for exact placement
        filename: filename,  // Use dynamically generated filename
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true, letterRendering: true },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
    }).from(tempContainer).save();
}

// Get the premium status from the Django template
const is_premium = {{ is_premium|yesno:"true,false" }}; // Converts Python True/False to JS true/false

// Restrict features for basic users
function restrictFeatures() {
    if (!is_premium) {
        document.getElementById("printBtn").disabled = true;
        document.getElementById("downloadBtn").disabled = true;

        // Add event listeners to show an upgrade message
        document.getElementById("printBtn").addEventListener("click", function() {
            alert("üîí This feature is only available for Premium users. Upgrade to export worksheets!");
        });

        document.getElementById("downloadBtn").addEventListener("click", function() {
            alert("üîí This feature is only available for Premium users. Upgrade to export worksheets!");
        });
    }
}

// Run the restriction function when the page loads
window.onload = function() {
    restrictFeatures();
};

    </script>
</body>
</html>